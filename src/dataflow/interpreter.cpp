/*
 * interpreter.cpp
 *
 * Created on: 26/03/2016
 *
 * =========================================================================
 *  Copyright (C) 2015-, Daniele De Sensi (d.desensi.software@gmail.com)
 *
 *  This file is part of nornir.
 *
 *  nornir is free software: you can redistribute it and/or
 *  modify it under the terms of the Lesser GNU General Public
 *  License as published by the Free Software Foundation, either
 *  version 3 of the License, or (at your option) any later version.

 *  nornir is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  Lesser GNU General Public License for more details.
 *
 *  You should have received a copy of the Lesser GNU General Public
 *  License along with nornir.
 *  If not, see <http://www.gnu.org/licenses/>.
 *
 * =========================================================================
 */

#include "interpreter.hpp"

namespace nornir{
namespace dataflow{

/**
 * This is a custom scheduler, that always send the Mdfi with id I to
 * the same worker. This guarantees that an instruction generated by the (N+1)-th
 * stream element, will always be processed after the instruction generated by
 * the N-th stream element terminated.
 */
class OrderedTasksScheduler: public nornir::Scheduler<Mdfi, Mdfi>{
private:
    size_t _numWorkers;
public:
    OrderedTasksScheduler(size_t numWorkers):_numWorkers(numWorkers){;}

    void notifyRethreading(size_t oldNumWorkers, size_t newNumWorkers){
        _numWorkers = newNumWorkers;
    }

    Mdfi* schedule(Mdfi* i){
        //std::cout << "Sending to: " << i->getId() % _numWorkers << std::endl;
        sendTo(i, i->getId() % _numWorkers);
        return (Mdfi*) GO_ON;
    }
};

WorkerMdf::WorkerMdf(ff::SWSR_Ptr_Buffer* buffer):_buffer(buffer){;}

void WorkerMdf::compute(Mdfi* t){
    std::vector<OutputToken>* temp = t->compute();
    _buffer->push(temp);
}

Interpreter::Interpreter(size_t maxWorkers, bool orderedTasks):
        _maxWorkers(maxWorkers), _lastRcvId(0), _tdl(new Mdfg*),
        _g(new Mdfg*){
    _p = new nornir::Parameters("parameters.xml", "archdata.xml");
    _o = new nornir::Observer;
    _p->observer = _o;

    _accelerator = new nornir::FarmAccelerator<Mdfi>(_p);
    _accelerator->addScheduler(new OrderedTasksScheduler(maxWorkers));

    /**Creates the SPSC queues.**/
    _buffers = new ff::SWSR_Ptr_Buffer*[_maxWorkers];
    for(size_t i = 0; i < _maxWorkers; i++){
        _buffers[i] = new ff::SWSR_Ptr_Buffer(1024);
        _buffers[i]->init();
    }
    /**Adds the workers to the farm.**/
    for(size_t i = 0; i < _maxWorkers; ++i){
        _accelerator->addWorker(new WorkerMdf(_buffers[i]));
    }
    _accelerator->start();
}

Interpreter::~Interpreter(){
     _accelerator->wait();
     for(size_t i = 0; i < _maxWorkers; i++){
         delete _buffers[i];
     }
     delete[] _buffers;
     delete _p;
     delete _o;
     delete _tdl;
     delete _g;
}

int Interpreter::get(std::vector<OutputToken>& ot){
    int acc = 0;
    void* task;
    size_t workerId = 0;
#if 1
    size_t maxSize = 0;
    size_t cSize = 0;
    for(size_t i = 0; i < _maxWorkers; i++){
        cSize = _buffers[workerId]->length();
        if(cSize > maxSize){
            maxSize = cSize;
            workerId = i;
        }
    }
#else
    workerId = (_lastRcvId + 1) % _accelerator->getCurrentNumWorkers();
    _lastRcvId++;
#endif


#ifdef COMPUTE_COM_TIME
    unsigned long t1;
    if(true){
        t1 = ff::getusec();
        if(!buffers[workerId]->pop(&task)) break;
        acc += ff::getusec()-t1;
#else
    if(_buffers[workerId]->pop(&task)){
#endif
        ot = *((std::vector<OutputToken>*) task);
        delete ((std::vector<OutputToken>*) task);
    }

    return acc;
}

int Interpreter::updateCompleted(hashMap<StreamElem*> *result, hashMap<Mdfg*> *graphs,
                    std::deque<Mdfg*> *pool, unsigned long int& tasksSent){
    OutputToken ot;
    unsigned long int graphId;
    TokenId dest;
    int acc = 0;
    std::vector<OutputToken>* temp;
    Mdfi *ins;
    void* task;
    uint collected = 0;
    size_t startId = 0;
    size_t workerId = 0;
    startId = rand();
    do{
        collected  = 0;
        for(size_t i = 0; i < _maxWorkers; i++){
            workerId = (i + startId) % _maxWorkers;
#ifdef COMPUTE_COM_TIME
            unsigned long t1;
            if(true){
                t1 = ff::getusec();
                if(!buffers[workerId]->pop(&task)) break;
                acc += ff::getusec()-t1;
#else
            if(_buffers[workerId]->pop(&task)){
#endif
                ++collected;
                temp = (std::vector<OutputToken>*) task;
                for(int j = 0; j < (int) temp->size(); j++){
                    ot = temp->at(j);
                    dest = ot.getDest();
                    graphId = dest.getGraphId();
                    /**
                     * If was the last instruction of a graph's copy, puts it
                     * into the output vector and delete
                     * the copy of the graph.
                     */
                    if(dest.isOutStream()){
                        result->put(graphId, ot.getResult());
                        graphs->get(graphId, _tdl);
                        graphs->erase(graphId);
        #ifdef POOL
                        if(pool->size() < MAXPOOLSIZE)
                            pool->push_back(*_tdl);
                        else
                            delete *_tdl;
        #else
                        delete *_tdl;
        #endif
                        --tasksSent;
                    }else{
                        /**Takes the pointer to the copy of the graph.**/
                        graphs->get(graphId, _g);
                        /**Takes the pointer to the instruction.**/
                        ins = (*_g)->getMdfi(dest.getMdfId());
                        /**Updates the instruction adding the input token.**/
                        ins->setInput(ot.getResult(), dest.getTokId());
                        /**
                         * If the instruction is fireable, adds it to the pool of
                         * fireable instructions.
                         **/
                        if(ins->isFireable()){
                            exec(ins);
                        }
                    }
                }
                delete temp;
            }
        }
    }while(false && collected);
    return acc;
}

/**
 * Waits for the results of the instructions passed to the interpreter.
 * \param r A queue of output tokens. In this queue the interpreter will puts the computed results.
 */
int Interpreter::wait(std::vector<OutputToken>& r){
    int acc = 0;
    std::vector<OutputToken>* temp;
    void* task;
    uint collected = 0;
    size_t startId = 0;
    size_t workerId = 0;
    startId = rand();
    do{
        collected  = 0;        
        for(size_t i = 0; i < _maxWorkers; i++){
            workerId = (i + startId) % _maxWorkers;
#ifdef COMPUTE_COM_TIME
            unsigned long t1;
            if(true){
                t1 = ff::getusec();
                if(!buffers[workerId]->pop(&task)) break;
                acc += ff::getusec()-t1;
#else
            if(_buffers[workerId]->pop(&task)){
#endif
                ++collected;
                temp = (std::vector<OutputToken>*) task;
                r.insert(r.end(), temp->begin(), temp->end());
                //                for(int j = 0; j < (int) temp->size(); j++)
                //                    r.push_back((*temp)[j]);
                delete temp;
            }
        }
    }while(collected);
    return acc;
}

}
}

