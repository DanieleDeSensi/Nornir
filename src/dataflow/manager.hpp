/*
 * manager.hpp
 *
 * Created on: 26/03/2016
 *
 * =========================================================================
 *  Copyright (C) 2015-, Daniele De Sensi (d.desensi.software@gmail.com)
 *
 *  This file is part of nornir.
 *
 *  nornir is free software: you can redistribute it and/or
 *  modify it under the terms of the Lesser GNU General Public
 *  License as published by the Free Software Foundation, either
 *  version 3 of the License, or (at your option) any later version.

 *  nornir is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  Lesser GNU General Public License for more details.
 *
 *  You should have received a copy of the Lesser GNU General Public
 *  License along with nornir.
 *  If not, see <http://www.gnu.org/licenses/>.
 *
 * =========================================================================
 */

#ifndef NORNIR_DF_MANAGER_HPP
#define NORNIR_DF_MANAGER_HPP

#include "interpreter.hpp"
#include "tokens.hpp"
#include "mdfg.hpp"
#include "stream.hpp"
#include "hashMap.hpp"
#include "skeleton/computable.hpp"
#include "skeleton/farm.hpp"
#include "skeleton/pipeline.hpp"
#include "skeleton/ewc.hpp"
#include <typeinfo>
#include <errno.h>
#include <deque>
#include <vector>

namespace nornir{
namespace dataflow{

/**
 * This is a recursive function that compiles a skeleton into a macro data flow graph.
 * \param c The skeleton to compile.
 */
Mdfg* compile(Computable* c);

/**
 * The manager of muskel.
 * The manager executes the skeleton (or the macro data flow graph).
 */
class Manager{
private:
    InputStream *_in;
    OutputStream *_out;
    /**A pointer to the interpreter.**/
    Interpreter *_intr;
    /**The macro data flow graph.**/
    Mdfg *_graph;
    /**True if the graph is a compiled graph.**/
    const bool _compiled;
    /**Next free graph identifier.**/
    unsigned long int _nextGraphId;
    /**Pool of usable graphs.**/
    std::deque<Mdfg*> *_pool;
    /**Instances of the graph.**/
    hashMap<Mdfg*> *_graphs;
    /**
     * Computed results. It's necessary to save them into a map for preserving
     * the order of the task received from the input stream. The results will
     * be periodically send to the output stream.
     **/
    hashMap<StreamElem*> *_result;

    unsigned long int
    /**Number of results not yet calculated.**/
        _taskSent,
    /**Index of the last task sent to the output stream.**/
        _lastSent;
    StreamElem** _tempTask;
#ifdef COMPUTE_COM_TIME
    unsigned long _acc;
#endif
public:
    /**
     * Constructor of the manager.
     * \param c The skeleton to be executed.
     * \param i The input stream.
     * \param o The output stream.
     * \param parDegree Number of workers to activate.
     * \param groupSize Number of instructions to send to the interpreter
     *                  before waiting the results.
     * \param orderedTasks If true, we will guarantee that a macro data flow
     *                     instruction generated by the stream element N + 1, will
     *                     always be executed before after the same instruction
     *                     generated by the stream element N terminated.
     */
    Manager(Computable *c, InputStream *i, OutputStream *o, int parDegree,
            unsigned long int groupSize, bool orderedTasks);

    /**
     * Constructor of the manager.
     * \param graph The macro data flow graph to be executed.
     * \param i The input stream.
     * \param o The output stream.
     * \param parDegree Number of workers to activate.
     * \param groupSize Number of instructions to send to the interpreter
     *                  before waiting the results.
     * \param orderedTasks If true, we will guarantee that a macro data flow
     *                     instruction generated by the stream element N + 1, will
     *                     always be executed before after the same instruction
     *                     generated by the stream element N terminated.
     */
    Manager(Mdfg *graph, InputStream *i, OutputStream *o, int parDegree,
            unsigned long int groupSize, bool orderedTasks);

    /**
     * Denstructor of the manager.
     */
    ~Manager();

    /**
     * Prints some stats.
     * \param out The stream where print the stats.
     */
    void stats(std::ostream& out);

    /**
     * Executes the skeleton (or the macro data flow graph).
     */
    void exec();
private:
    /**
     * Tries to receive new tasks from the input stream.
     **/
    void getFromInput();

    /**
     * Sends new results to the output stream, preserving the order of the
     * task received from the input stream.
     */
    void flushOnStream();

};
}
}
#endif // NORNIR_DF_MANAGER_HPP
